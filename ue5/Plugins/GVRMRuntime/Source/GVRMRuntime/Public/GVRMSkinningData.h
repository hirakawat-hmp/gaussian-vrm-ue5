// Copyright (c) 2025 gaussian-vrm community
// Licensed under the MIT License.

#pragma once

#include "CoreMinimal.h"
#include "Engine/DataAsset.h"
#include "GVRMSkinningData.generated.h"

/**
 * Single splat binding information.
 * Maps a Gaussian splat to a VRM mesh vertex and bone.
 */
USTRUCT(BlueprintType)
struct GVRMRUNTIME_API FSplatBindingInfo
{
	GENERATED_BODY()

	/** Index of this splat in the splat array */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "GVRM")
	int32 SplatIndex = 0;

	/** Index of the VRM mesh vertex this splat is bound to */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "GVRM")
	int32 VertexIndex = 0;

	/** Index of the VRM skeleton bone this splat is bound to */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "GVRM")
	int32 BoneIndex = -1;

	/** Relative position from the vertex to the splat (in local space) */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "GVRM")
	FVector RelativePosition = FVector::ZeroVector;

	FSplatBindingInfo()
		: SplatIndex(0)
		, VertexIndex(0)
		, BoneIndex(-1)
		, RelativePosition(FVector::ZeroVector)
	{
	}

	FSplatBindingInfo(int32 InSplatIndex, int32 InVertexIndex, int32 InBoneIndex, const FVector& InRelativePosition)
		: SplatIndex(InSplatIndex)
		, VertexIndex(InVertexIndex)
		, BoneIndex(InBoneIndex)
		, RelativePosition(InRelativePosition)
	{
	}
};

/**
 * Bone operation data from GVRM preprocessing.
 * Represents pose adjustments applied to VRM skeleton bones.
 */
USTRUCT(BlueprintType)
struct GVRMRUNTIME_API FGVRMBoneOperation
{
	GENERATED_BODY()

	/** Name of the bone to operate on */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "GVRM")
	FString BoneName;

	/** Position offset to apply */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "GVRM")
	FVector PositionOffset = FVector::ZeroVector;

	/** Rotation to apply (in degrees) */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "GVRM")
	FRotator Rotation = FRotator::ZeroRotator;

	FGVRMBoneOperation()
		: BoneName(TEXT(""))
		, PositionOffset(FVector::ZeroVector)
		, Rotation(FRotator::ZeroRotator)
	{
	}
};

/**
 * GVRM Binding Data Asset.
 * Contains all splat-to-vertex/bone binding information from a GVRM file.
 *
 * This asset is generated by the gvrm_to_ue5.py tool from data.json.
 */
UCLASS(BlueprintType)
class GVRMRUNTIME_API UGVRMBindingData : public UDataAsset
{
	GENERATED_BODY()

public:
	/** Array of all splat bindings */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "GVRM")
	TArray<FSplatBindingInfo> Bindings;

	/** Scale factor applied to VRM model during preprocessing */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "GVRM")
	float ModelScale = 1.0f;

	/** Bone operations applied during preprocessing (e.g., A-pose adjustments) */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "GVRM")
	TArray<FGVRMBoneOperation> BoneOperations;

	/** GVRM file format version */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "GVRM")
	FString Version = TEXT("1.0");

	/**
	 * Get the number of splats in this binding data.
	 */
	UFUNCTION(BlueprintCallable, Category = "GVRM")
	int32 GetSplatCount() const
	{
		return Bindings.Num();
	}

	/**
	 * Get binding info for a specific splat index.
	 */
	UFUNCTION(BlueprintCallable, Category = "GVRM")
	bool GetBindingInfo(int32 SplatIndex, FSplatBindingInfo& OutBindingInfo) const
	{
		if (SplatIndex >= 0 && SplatIndex < Bindings.Num())
		{
			OutBindingInfo = Bindings[SplatIndex];
			return true;
		}
		return false;
	}

	/**
	 * Find bone operation by bone name.
	 */
	UFUNCTION(BlueprintCallable, Category = "GVRM")
	bool FindBoneOperation(const FString& BoneName, FGVRMBoneOperation& OutOperation) const
	{
		for (const FGVRMBoneOperation& Op : BoneOperations)
		{
			if (Op.BoneName.Equals(BoneName, ESearchCase::IgnoreCase))
			{
				OutOperation = Op;
				return true;
			}
		}
		return false;
	}

	/**
	 * Validate binding data integrity.
	 * Checks for duplicate splat indices and valid vertex/bone indices.
	 */
	UFUNCTION(BlueprintCallable, Category = "GVRM")
	bool ValidateBindings(FString& OutErrorMessage) const
	{
		if (Bindings.Num() == 0)
		{
			OutErrorMessage = TEXT("No bindings found");
			return false;
		}

		// Check for duplicate splat indices
		TSet<int32> SplatIndices;
		for (const FSplatBindingInfo& Binding : Bindings)
		{
			if (SplatIndices.Contains(Binding.SplatIndex))
			{
				OutErrorMessage = FString::Printf(TEXT("Duplicate splat index: %d"), Binding.SplatIndex);
				return false;
			}
			SplatIndices.Add(Binding.SplatIndex);

			// Validate indices
			if (Binding.VertexIndex < 0)
			{
				OutErrorMessage = FString::Printf(TEXT("Invalid vertex index at splat %d: %d"),
					Binding.SplatIndex, Binding.VertexIndex);
				return false;
			}
		}

		OutErrorMessage = TEXT("Validation successful");
		return true;
	}

#if WITH_EDITOR
	/**
	 * Import from CSV file generated by gvrm_to_ue5.py
	 */
	bool ImportFromCSV(const FString& CSVFilePath, FString& OutErrorMessage);

	/**
	 * Import metadata from JSON file generated by gvrm_to_ue5.py
	 */
	bool ImportMetadataFromJSON(const FString& JSONFilePath, FString& OutErrorMessage);
#endif
};

/**
 * Runtime GPU buffer data for GVRM splat rendering.
 * Prepared from UGVRMBindingData for upload to GPU.
 */
USTRUCT()
struct GVRMRUNTIME_API FGVRMSplatGPUData
{
	GENERATED_BODY()

	/** Vertex indices (one per splat) */
	TArray<int32> SplatVertexIndices;

	/** Relative positions (one per splat) */
	TArray<FVector3f> SplatRelativePositions;

	/** Bone indices (one per splat, optional) */
	TArray<int32> SplatBoneIndices;

	/** Number of splats */
	int32 NumSplats = 0;

	/**
	 * Initialize from binding data asset.
	 */
	void InitializeFromBindingData(const UGVRMBindingData* BindingData)
	{
		if (!BindingData)
		{
			NumSplats = 0;
			return;
		}

		NumSplats = BindingData->GetSplatCount();
		SplatVertexIndices.SetNum(NumSplats);
		SplatRelativePositions.SetNum(NumSplats);
		SplatBoneIndices.SetNum(NumSplats);

		for (int32 i = 0; i < NumSplats; ++i)
		{
			const FSplatBindingInfo& Binding = BindingData->Bindings[i];
			SplatVertexIndices[i] = Binding.VertexIndex;
			SplatRelativePositions[i] = FVector3f(Binding.RelativePosition);
			SplatBoneIndices[i] = Binding.BoneIndex;
		}
	}
};
