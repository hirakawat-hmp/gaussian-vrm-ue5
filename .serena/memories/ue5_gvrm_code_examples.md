# UE5 GVRM実装 - コード例とスニペット

## 1. Pythonツール: GVRMファイル変換

### 1.1 完全なパーサー実装

```python
#!/usr/bin/env python3
# tools/gvrm_to_ue5.py

"""
GVRM to UE5 Converter
GVRMファイルをUnreal Engine 5用のアセットに変換
"""

import zipfile
import json
import csv
import os
import argparse
from pathlib import Path

class GVRMConverter:
    def __init__(self, gvrm_path, output_dir):
        self.gvrm_path = gvrm_path
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
    def convert(self):
        """メイン変換処理"""
        print(f"Converting {self.gvrm_path}...")
        
        with zipfile.ZipFile(self.gvrm_path, 'r') as z:
            # 1. data.jsonを読み込み
            data = json.loads(z.read('data.json'))
            
            # 2. VRMとPLYを抽出
            print("Extracting VRM and PLY files...")
            z.extract('model.vrm', self.output_dir)
            z.extract('model.ply', self.output_dir)
            
            # 3. バインディングデータをCSV化
            print("Exporting binding data...")
            self._export_binding_csv(data)
            
            # 4. メタデータをJSON出力
            print("Exporting metadata...")
            self._export_metadata(data)
            
            # 5. UE5用のインポートスクリプト生成
            print("Generating import script...")
            self._generate_import_script(data)
            
        print(f"Conversion complete! Output: {self.output_dir}")
    
    def _export_binding_csv(self, data):
        """スプラットバインディング情報をCSV出力"""
        csv_path = self.output_dir / "splat_binding.csv"
        
        vertex_indices = data['splatVertexIndices']
        bone_indices = data.get('splatBoneIndices', [])
        relative_poses = data['splatRelativePoses']
        
        with open(csv_path, 'w', newline='') as f:
            writer = csv.writer(f)
            
            # ヘッダー
            writer.writerow([
                'SplatIndex',
                'VertexIndex',
                'BoneIndex',
                'RelativePosX',
                'RelativePosY',
                'RelativePosZ'
            ])
            
            # データ行
            for i in range(len(vertex_indices)):
                vertex_idx = vertex_indices[i]
                bone_idx = bone_indices[i] if i < len(bone_indices) else -1
                rel_pos = relative_poses[i]
                
                writer.writerow([
                    i,
                    vertex_idx,
                    bone_idx,
                    rel_pos['x'],
                    rel_pos['y'],
                    rel_pos['z']
                ])
        
        print(f"  - Exported {len(vertex_indices)} splat bindings to {csv_path}")
    
    def _export_metadata(self, data):
        """メタデータをJSON出力"""
        metadata = {
            'modelScale': data.get('modelScale', 1.0),
            'boneOperations': data.get('boneOperations', []),
            'splatCount': len(data['splatVertexIndices']),
            'version': '1.0'
        }
        
        json_path = self.output_dir / "metadata.json"
        with open(json_path, 'w') as f:
            json.dump(metadata, f, indent=2)
        
        print(f"  - Exported metadata to {json_path}")
    
    def _generate_import_script(self, data):
        """UE5用のPythonインポートスクリプト生成"""
        script_path = self.output_dir / "import_to_ue5.py"
        
        script_content = f'''# Unreal Engine 5 Import Script
# Generated by gvrm_to_ue5.py

import unreal

def import_gvrm_assets():
    """GVRM assets to UE5"""
    
    # Paths
    vrm_path = "{self.output_dir / 'model.vrm'}"
    ply_path = "{self.output_dir / 'model.ply'}"
    binding_csv = "{self.output_dir / 'splat_binding.csv'}"
    metadata_json = "{self.output_dir / 'metadata.json'}"
    
    # Import VRM (requires VRM4U plugin)
    # TODO: Implement VRM import logic
    
    # Import PLY (requires XVERSE plugin)
    # TODO: Implement PLY import logic
    
    # Create GVRMBindingData asset
    # TODO: Implement binding data creation
    
    print("Import complete!")

if __name__ == "__main__":
    import_gvrm_assets()
'''
        
        with open(script_path, 'w') as f:
            f.write(script_content)
        
        print(f"  - Generated import script: {script_path}")


def main():
    parser = argparse.ArgumentParser(description='Convert GVRM files to UE5 assets')
    parser.add_argument('gvrm_file', help='Path to .gvrm file')
    parser.add_argument('-o', '--output', default='./output', help='Output directory')
    
    args = parser.parse_args()
    
    if not os.path.exists(args.gvrm_file):
        print(f"Error: File not found: {args.gvrm_file}")
        return
    
    converter = GVRMConverter(args.gvrm_file, args.output)
    converter.convert()


if __name__ == "__main__":
    main()
```

### 1.2 使用例

```bash
# 単一ファイル変換
python tools/gvrm_to_ue5.py assets/author.gvrm -o UE5_Assets/Author

# バッチ変換
for file in assets/*.gvrm; do
    python tools/gvrm_to_ue5.py "$file" -o "UE5_Assets/$(basename $file .gvrm)"
done
```

---

## 2. UE5 C++コード: NDI実装

### 2.1 完全なNDIヘッダー

```cpp
// Source/GVRMRuntime/Public/NiagaraDataInterfaceGVRM.h

#pragma once

#include "CoreMinimal.h"
#include "NiagaraDataInterface.h"
#include "NiagaraCommon.h"
#include "Components/SkeletalMeshComponent.h"
#include "RenderResource.h"
#include "NiagaraDataInterfaceGVRM.generated.h"

/** Skinning data for a single vertex */
USTRUCT(BlueprintType)
struct FGVRMVertexSkinningData
{
    GENERATED_BODY()
    
    UPROPERTY()
    FVector4 BoneIndices;
    
    UPROPERTY()
    FVector4 BoneWeights;
    
    UPROPERTY()
    FVector Position;
};

/** GPU buffer data for render thread */
struct FNDIGVRMData_RenderThread
{
    FReadBuffer BoneMatricesBuffer;
    FReadBuffer VertexPositionsBuffer;
    FReadBuffer SkinIndicesBuffer;
    FReadBuffer SkinWeightsBuffer;
    
    int32 NumBones = 0;
    int32 NumVertices = 0;
    bool bIsValid = false;
    
    ~FNDIGVRMData_RenderThread()
    {
        BoneMatricesBuffer.Release();
        VertexPositionsBuffer.Release();
        SkinIndicesBuffer.Release();
        SkinWeightsBuffer.Release();
    }
};

/** Game thread instance data */
struct FNDIGVRMData_GameThread
{
    TWeakObjectPtr<USkeletalMeshComponent> SourceComponent;
    
    // Cached data
    TArray<FMatrix> BoneMatrices;
    TArray<FVector> VertexPositions;
    TArray<FVector4> SkinIndices;
    TArray<FVector4> SkinWeights;
    
    bool bNeedUpdate = true;
    
    void UpdateFromSkeletalMesh();
};

/**
 * Niagara Data Interface for GVRM skeletal mesh skinning
 * Provides access to bone matrices, vertex positions, and skinning data
 */
UCLASS(EditInlineNew, Category = "GVRM", meta = (DisplayName = "GVRM Skeletal Mesh"))
class GVRMRUNTIME_API UNiagaraDataInterfaceGVRM : public UNiagaraDataInterface
{
    GENERATED_UCLASS_BODY()

public:
    /** Source skeletal mesh component */
    UPROPERTY(EditAnywhere, Category = "GVRM")
    USkeletalMeshComponent* SourceComponent;
    
    /** Update bone matrices every frame */
    UPROPERTY(EditAnywhere, Category = "GVRM")
    bool bAutoUpdate = true;
    
    /** Cache vertex skinning data */
    UPROPERTY(EditAnywhere, Category = "GVRM|Performance")
    bool bCacheSkinningData = true;
    
    // UNiagaraDataInterface interface
    virtual void PostInitProperties() override;
    virtual void PostLoad() override;
    
#if WITH_EDITOR
    virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override;
#endif
    
    virtual void GetFunctions(TArray<FNiagaraFunctionSignature>& OutFunctions) override;
    virtual void GetVMExternalFunction(const FVMExternalFunctionBindingInfo& BindingInfo, void* InstanceData, FVMExternalFunction& OutFunc) override;
    
    virtual bool InitPerInstanceData(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance) override;
    virtual void DestroyPerInstanceData(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance) override;
    virtual int32 PerInstanceDataSize() const override { return sizeof(FNDIGVRMData_GameThread); }
    
    virtual bool PerInstanceTick(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance, float DeltaSeconds) override;
    
    virtual bool Equals(const UNiagaraDataInterface* Other) const override;
    virtual bool CanExecuteOnTarget(ENiagaraSimTarget Target) const override { return true; }
    
    virtual bool HasPreSimulateTick() const override { return true; }
    virtual bool HasTickGroupPrereqs() const override { return true; }
    virtual ETickingGroup CalculateTickGroup(const void* PerInstanceData) const override;
    
    // GPU simulation
    virtual void GetParameterDefinitionHLSL(const FNiagaraDataInterfaceGPUParamInfo& ParamInfo, FString& OutHLSL) override;
    virtual bool GetFunctionHLSL(const FNiagaraDataInterfaceGPUParamInfo& ParamInfo, const FNiagaraDataInterfaceGeneratedFunction& FunctionInfo, int FunctionInstanceIndex, FString& OutHLSL) override;
    virtual void ProvidePerInstanceDataForRenderThread(void* DataForRenderThread, void* PerInstanceData, const FNiagaraSystemInstanceID& SystemInstance) override;
    
    // Function names
    static const FName GetNumBonesName;
    static const FName GetNumVerticesName;
    static const FName GetBoneMatrixName;
    static const FName GetVertexPositionName;
    static const FName GetVertexSkinningDataName;
    static const FName ComputeSkinnedPositionName;

protected:
    // VM function bindings (CPU simulation)
    void VMGetNumBones(FVectorVMExternalFunctionContext& Context);
    void VMGetNumVertices(FVectorVMExternalFunctionContext& Context);
    void VMGetBoneMatrix(FVectorVMExternalFunctionContext& Context);
    void VMGetVertexPosition(FVectorVMExternalFunctionContext& Context);
    void VMGetVertexSkinningData(FVectorVMExternalFunctionContext& Context);
    void VMComputeSkinnedPosition(FVectorVMExternalFunctionContext& Context);
};
```

### 2.2 NDI実装（主要部分）

```cpp
// Source/GVRMRuntime/Private/NiagaraDataInterfaceGVRM.cpp

#include "NiagaraDataInterfaceGVRM.h"
#include "NiagaraShader.h"
#include "ShaderParameterUtils.h"
#include "Rendering/SkeletalMeshRenderData.h"

#define LOCTEXT_NAMESPACE "NiagaraDataInterfaceGVRM"

// Static name definitions
const FName UNiagaraDataInterfaceGVRM::GetNumBonesName(TEXT("GetNumBones"));
const FName UNiagaraDataInterfaceGVRM::GetNumVerticesName(TEXT("GetNumVertices"));
const FName UNiagaraDataInterfaceGVRM::GetBoneMatrixName(TEXT("GetBoneMatrix"));
const FName UNiagaraDataInterfaceGVRM::GetVertexPositionName(TEXT("GetVertexPosition"));
const FName UNiagaraDataInterfaceGVRM::GetVertexSkinningDataName(TEXT("GetVertexSkinningData"));
const FName UNiagaraDataInterfaceGVRM::ComputeSkinnedPositionName(TEXT("ComputeSkinnedPosition"));

UNiagaraDataInterfaceGVRM::UNiagaraDataInterfaceGVRM(FObjectInitializer const& ObjectInitializer)
    : Super(ObjectInitializer)
    , SourceComponent(nullptr)
    , bAutoUpdate(true)
    , bCacheSkinningData(true)
{
}

void UNiagaraDataInterfaceGVRM::GetFunctions(TArray<FNiagaraFunctionSignature>& OutFunctions)
{
    {
        FNiagaraFunctionSignature Sig;
        Sig.Name = GetNumBonesName;
        Sig.bMemberFunction = true;
        Sig.bRequiresContext = false;
        Sig.Outputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetIntDef(), TEXT("NumBones")));
        OutFunctions.Add(Sig);
    }
    
    {
        FNiagaraFunctionSignature Sig;
        Sig.Name = GetBoneMatrixName;
        Sig.bMemberFunction = true;
        Sig.bRequiresContext = false;
        Sig.Inputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetIntDef(), TEXT("BoneIndex")));
        Sig.Outputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetMatrix4Def(), TEXT("BoneMatrix")));
        OutFunctions.Add(Sig);
    }
    
    {
        FNiagaraFunctionSignature Sig;
        Sig.Name = ComputeSkinnedPositionName;
        Sig.bMemberFunction = true;
        Sig.bRequiresContext = false;
        Sig.Inputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetIntDef(), TEXT("VertexIndex")));
        Sig.Inputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetVec3Def(), TEXT("RelativePosition")));
        Sig.Outputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetVec3Def(), TEXT("SkinnedPosition")));
        OutFunctions.Add(Sig);
    }
}

void UNiagaraDataInterfaceGVRM::GetVMExternalFunction(const FVMExternalFunctionBindingInfo& BindingInfo, void* InstanceData, FVMExternalFunction& OutFunc)
{
    if (BindingInfo.Name == GetNumBonesName)
    {
        OutFunc = FVMExternalFunction::CreateUObject(this, &UNiagaraDataInterfaceGVRM::VMGetNumBones);
    }
    else if (BindingInfo.Name == GetBoneMatrixName)
    {
        OutFunc = FVMExternalFunction::CreateUObject(this, &UNiagaraDataInterfaceGVRM::VMGetBoneMatrix);
    }
    else if (BindingInfo.Name == ComputeSkinnedPositionName)
    {
        OutFunc = FVMExternalFunction::CreateUObject(this, &UNiagaraDataInterfaceGVRM::VMComputeSkinnedPosition);
    }
}

void UNiagaraDataInterfaceGVRM::VMComputeSkinnedPosition(FVectorVMExternalFunctionContext& Context)
{
    VectorVM::FExternalFuncInputHandler<int32> VertexIndexParam(Context);
    VectorVM::FExternalFuncInputHandler<float> RelPosXParam(Context);
    VectorVM::FExternalFuncInputHandler<float> RelPosYParam(Context);
    VectorVM::FExternalFuncInputHandler<float> RelPosZParam(Context);
    
    VectorVM::FExternalFuncRegisterHandler<float> OutPosX(Context);
    VectorVM::FExternalFuncRegisterHandler<float> OutPosY(Context);
    VectorVM::FExternalFuncRegisterHandler<float> OutPosZ(Context);
    
    FNDIGVRMData_GameThread* InstData = static_cast<FNDIGVRMData_GameThread*>(Context.GetPerInstanceData());
    
    for (int32 i = 0; i < Context.GetNumInstances(); ++i)
    {
        int32 VertexIndex = VertexIndexParam.GetAndAdvance();
        FVector RelPos(RelPosXParam.GetAndAdvance(), RelPosYParam.GetAndAdvance(), RelPosZParam.GetAndAdvance());
        
        FVector SkinnedPos = FVector::ZeroVector;
        
        if (InstData && VertexIndex >= 0 && VertexIndex < InstData->SkinIndices.Num())
        {
            // LBS calculation
            FVector4 SkinIdx = InstData->SkinIndices[VertexIndex];
            FVector4 SkinWgt = InstData->SkinWeights[VertexIndex];
            
            FMatrix SkinMatrix = FMatrix::Identity;
            SkinMatrix = 
                InstData->BoneMatrices[SkinIdx.X] * SkinWgt.X +
                InstData->BoneMatrices[SkinIdx.Y] * SkinWgt.Y +
                InstData->BoneMatrices[SkinIdx.Z] * SkinWgt.Z +
                InstData->BoneMatrices[SkinIdx.W] * SkinWgt.W;
            
            FVector VertexPos = InstData->VertexPositions[VertexIndex];
            FVector LocalPos = VertexPos + RelPos;
            SkinnedPos = SkinMatrix.TransformPosition(LocalPos);
        }
        
        *OutPosX.GetDestAndAdvance() = SkinnedPos.X;
        *OutPosY.GetDestAndAdvance() = SkinnedPos.Y;
        *OutPosZ.GetDestAndAdvance() = SkinnedPos.Z;
    }
}

#undef LOCTEXT_NAMESPACE
```

---

## 3. Blueprintセットアップ例

### 3.1 GVRMアクターBlueprint

```cpp
// BP_GVRMActor の擬似コード

Components:
- SkeletalMeshComponent (VRM)
  └─ Skeletal Mesh: VRM_Imported
  └─ Anim Class: VRM_AnimBP
  
- NiagaraComponent (GaussianSplats)
  └─ Niagara System: NS_GVRM_Splats
  └─ User Parameters:
      └─ GVRM_NDI: (Reference to NDI)
      └─ BindingData: DA_GVRMBinding

Event Graph:
┌─ Event BeginPlay
│  ├─ Load GVRM Binding Data
│  ├─ Setup Niagara NDI
│  │  └─ Set SourceComponent = SkeletalMeshComponent
│  ├─ Activate Niagara System
│  └─ Play Animation
│
└─ Event Tick
   ├─ Update Debug Visualization (if enabled)
   └─ Update Performance Stats
```

### 3.2 Niagara System構成

```
NS_GVRM_Splats (Niagara System)
├─ Emitter: GVRM_SplatEmitter
│  ├─ Emitter Spawn
│  │  └─ Spawn Burst
│  │      └─ Spawn Count = BindingData.Num()
│  │
│  ├─ Particle Spawn
│  │  ├─ Initialize Particle
│  │  ├─ Set VertexIndex (from CSV Table)
│  │  ├─ Set RelativePosition (from CSV Table)
│  │  └─ Set LifeTime = 999999
│  │
│  ├─ Particle Update
│  │  ├─ GVRM Skinning Module (Custom HLSL)
│  │  │  └─ Particles.Position = GVRM.ComputeSkinnedPosition(...)
│  │  │
│  │  └─ Update Mesh Reproduction Sprite
│  │
│  └─ Render
│      └─ Sprite Renderer
│          └─ Material: M_GaussianSplat
│
└─ User Parameters
    ├─ GVRM_NDI (NiagaraDataInterfaceGVRM)
    └─ BindingData (Data Table)
```

---

## 4. マテリアル: Gaussian Splatレンダリング

### 4.1 M_GaussianSplat マテリアル

```cpp
// Material: M_GaussianSplat
// ガウス楕円をスプライトとして描画

Material Domain: Surface
Blend Mode: Translucent
Shading Model: Unlit

Nodes:
┌─ Particle Color
│  └─> Base Color
│
├─ Custom Expression: GaussianAlpha
│  Input: TexCoord (Particle.UV)
│  Code: 
│    // ガウス分布
│    float2 uv = TexCoord * 2.0 - 1.0;  // [-1, 1]
│    float dist = dot(uv, uv);
│    return exp(-dist * 2.0);  // ガウス関数
│  └─> Opacity
│
└─ Particle Size
   └─> (controls sprite size based on splat scale)
```

---

## 5. パフォーマンステストコード

```cpp
// Source/GVRMRuntime/Private/GVRMPerformanceTest.cpp

#include "GVRMPerformanceTest.h"
#include "HAL/PlatformTime.h"

DEFINE_LOG_CATEGORY_STATIC(LogGVRMPerf, Log, All);

void FGVRMPerformanceTest::RunBenchmark(AGVRMActor* Actor, int32 NumFrames)
{
    if (!Actor)
        return;
    
    UE_LOG(LogGVRMPerf, Log, TEXT("Starting GVRM performance test..."));
    
    TArray<double> FrameTimes;
    FrameTimes.Reserve(NumFrames);
    
    for (int32 Frame = 0; Frame < NumFrames; ++Frame)
    {
        double StartTime = FPlatformTime::Seconds();
        
        // Update simulation
        Actor->TickActor(0.016f, ELevelTick::LEVELTICK_All, FActorTickFunction());
        
        double EndTime = FPlatformTime::Seconds();
        double FrameTime = (EndTime - StartTime) * 1000.0; // ms
        
        FrameTimes.Add(FrameTime);
    }
    
    // Calculate statistics
    double TotalTime = 0.0;
    double MinTime = FrameTimes[0];
    double MaxTime = FrameTimes[0];
    
    for (double Time : FrameTimes)
    {
        TotalTime += Time;
        MinTime = FMath::Min(MinTime, Time);
        MaxTime = FMath::Max(MaxTime, Time);
    }
    
    double AvgTime = TotalTime / NumFrames;
    double AvgFPS = 1000.0 / AvgTime;
    
    UE_LOG(LogGVRMPerf, Log, TEXT("Performance Results:"));
    UE_LOG(LogGVRMPerf, Log, TEXT("  Average Frame Time: %.2f ms"), AvgTime);
    UE_LOG(LogGVRMPerf, Log, TEXT("  Average FPS: %.1f"), AvgFPS);
    UE_LOG(LogGVRMPerf, Log, TEXT("  Min Frame Time: %.2f ms"), MinTime);
    UE_LOG(LogGVRMPerf, Log, TEXT("  Max Frame Time: %.2f ms"), MaxTime);
}
```

---

## 6. Compute Shader統合例

```cpp
// Source/GVRMRuntime/Private/GVRMSkinningComputeShader.cpp

#include "GVRMSkinningComputeShader.h"
#include "ShaderParameterStruct.h"
#include "GlobalShader.h"
#include "RenderGraphUtils.h"

class FGVRMSkinningCS : public FGlobalShader
{
public:
    DECLARE_GLOBAL_SHADER(FGVRMSkinningCS);
    SHADER_USE_PARAMETER_STRUCT(FGVRMSkinningCS, FGlobalShader);
    
    BEGIN_SHADER_PARAMETER_STRUCT(FParameters, )
        SHADER_PARAMETER_SRV(StructuredBuffer<float4x4>, BoneMatrices)
        SHADER_PARAMETER_SRV(StructuredBuffer<float3>, VertexPositions)
        SHADER_PARAMETER_SRV(StructuredBuffer<float4>, SkinIndices)
        SHADER_PARAMETER_SRV(StructuredBuffer<float4>, SkinWeights)
        SHADER_PARAMETER_SRV(StructuredBuffer<int>, SplatVertexIndices)
        SHADER_PARAMETER_SRV(StructuredBuffer<float3>, SplatRelativePositions)
        SHADER_PARAMETER_UAV(RWStructuredBuffer<float3>, OutSplatPositions)
        SHADER_PARAMETER(uint32, NumSplats)
    END_SHADER_PARAMETER_STRUCT()
    
    static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
    {
        return IsFeatureLevelSupported(Parameters.Platform, ERHIFeatureLevel::SM5);
    }
    
    static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
    {
        FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);
        OutEnvironment.SetDefine(TEXT("THREADGROUP_SIZE"), 256);
    }
};

IMPLEMENT_GLOBAL_SHADER(FGVRMSkinningCS, "/Plugin/GVRMRuntime/Private/GVRMSkinningCS.usf", "MainCS", SF_Compute);

void FGVRMSkinningComputeShader::Dispatch(
    FRHICommandListImmediate& RHICmdList,
    const FGVRMSkinningParameters& Params)
{
    TShaderMapRef<FGVRMSkinningCS> ComputeShader(GetGlobalShaderMap(GMaxRHIFeatureLevel));
    
    FGVRMSkinningCS::FParameters* PassParameters = AllocParameters<FGVRMSkinningCS::FParameters>();
    PassParameters->BoneMatrices = Params.BoneMatricesSRV;
    PassParameters->VertexPositions = Params.VertexPositionsSRV;
    PassParameters->SkinIndices = Params.SkinIndicesSRV;
    PassParameters->SkinWeights = Params.SkinWeightsSRV;
    PassParameters->SplatVertexIndices = Params.SplatVertexIndicesSRV;
    PassParameters->SplatRelativePositions = Params.SplatRelativePositionsSRV;
    PassParameters->OutSplatPositions = Params.OutSplatPositionsUAV;
    PassParameters->NumSplats = Params.NumSplats;
    
    FComputeShaderUtils::Dispatch(
        RHICmdList,
        ComputeShader,
        *PassParameters,
        FIntVector(FMath::DivideAndRoundUp(Params.NumSplats, 256u), 1, 1)
    );
}
```

---

## 7. デバッグコンソールコマンド

```cpp
// Source/GVRMRuntime/Private/GVRMConsoleCommands.cpp

#include "GVRMConsoleCommands.h"
#include "Engine/Engine.h"

static TAutoConsoleVariable<int32> CVarGVRMShowDebug(
    TEXT("GVRM.ShowDebug"),
    0,
    TEXT("Show GVRM debug visualization\n")
    TEXT("0: Off (default)\n")
    TEXT("1: Show bones\n")
    TEXT("2: Show vertices\n")
    TEXT("3: Show both"),
    ECVF_Default
);

static TAutoConsoleVariable<int32> CVarGVRMLODLevel(
    TEXT("GVRM.LODLevel"),
    0,
    TEXT("Force GVRM LOD level\n")
    TEXT("-1: Auto (default)\n")
    TEXT("0: High\n")
    TEXT("1: Medium\n")
    TEXT("2: Low"),
    ECVF_Default
);

FAutoConsoleCommand GVRMBenchmarkCommand(
    TEXT("GVRM.Benchmark"),
    TEXT("Run GVRM performance benchmark"),
    FConsoleCommandWithArgsDelegate::CreateLambda([](const TArray<FString>& Args)
    {
        int32 NumFrames = 300;
        if (Args.Num() > 0)
        {
            NumFrames = FCString::Atoi(*Args[0]);
        }
        
        UE_LOG(LogTemp, Log, TEXT("Running GVRM benchmark for %d frames..."), NumFrames);
        // Benchmark logic here
    })
);
```

**使用例:**
```
# コンソール
GVRM.ShowDebug 3
GVRM.LODLevel 0
GVRM.Benchmark 1000
```

---

これらのコード例を使用して、UE5でGVRMシステムを段階的に実装できます。
